import React, { useState, useRef, useEffect } from "react";
import Nav from "../components/Nav";
import styles from "../styles/MyPageHeader.module.css";
import { FiSettings, FiCamera } from "react-icons/fi";
import { FaPlay, FaPause } from "react-icons/fa";
import { useCoverColor } from "../contexts/CoverColorContext";
import { HexColorPicker } from "react-colorful";
import mypageHeaderData from "../data/mypageheaderData.json";
import "../global.css";

export default function MyPageHeader({ authToken = null }) {
  const [data, setData] = useState({
    ...mypageHeaderData,
    quote: {
      title: "Ïù∏ÏÉÅ ÍπäÏùÄ Ï±ÖÏù¥ÎÇò Íµ¨Ï†àÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî",
      text: "ÎãπÏã†ÎßåÏùò ÌäπÎ≥ÑÌïú Î¨∏Íµ¨Î•º Ïó¨Í∏∞Ïóê ÎÇ®Í≤®Î≥¥ÏÑ∏Ïöî",
    },
  });
  const [isEditing, setIsEditing] = useState(false);
  const [selectedImage, setSelectedImage] = useState(null);
  const [editedUsername, setEditedUsername] = useState(
    mypageHeaderData.user.username
  );
  const [editedQuoteTitle, setEditedQuoteTitle] = useState(
    "Ïù∏ÏÉÅ ÍπäÏùÄ Ï±ÖÏù¥ÎÇò Íµ¨Ï†àÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî"
  );
  const [editedQuoteText, setEditedQuoteText] = useState(
    "ÎãπÏã†ÎßåÏùò ÌäπÎ≥ÑÌïú Î¨∏Íµ¨Î•º Ïó¨Í∏∞Ïóê ÎÇ®Í≤®Î≥¥ÏÑ∏Ïöî"
  );
  const [isColorPickerOpen, setIsColorPickerOpen] = useState(false);
  const [selectedColor, setSelectedColor] = useState("#15719E");
  const [showCustomColorInput, setShowCustomColorInput] = useState(false);
  const [customColor, setCustomColor] = useState("#15719E");
  const [searchQuery, setSearchQuery] = useState("");
  const [userName, setUserName] = useState("");
  const [quoteCount, setQuoteCount] = useState(0);
  const [isImageLoading, setIsImageLoading] = useState(true);
  const [isMusicDataLoading, setIsMusicDataLoading] = useState(true);

  // Î∞±ÏóîÎìú Ïó∞Í≤∞Ïö© ÏÉÅÌÉú Ï∂îÍ∞Ä
  const [isSaving, setIsSaving] = useState(false);
  const [saveError, setSaveError] = useState(null);
  const [isUploadingImage, setIsUploadingImage] = useState(false);

  // ÏùåÏïÖ Í¥ÄÎ†® state
  const [musicData, setMusicData] = useState({
    id: null,
    song: "ÏùåÏïÖÏùÑ Í≤ÄÏÉâÌï¥Î≥¥ÏÑ∏Ïöî",
    artist: "ÏïÑÌã∞Ïä§Ìä∏",
    album: "",
    image: null,
    preview: null,
  });
  const [isPlaying, setIsPlaying] = useState(false);
  const [showMusicSearch, setShowMusicSearch] = useState(false);
  const [searchResults, setSearchResults] = useState([]);
  const [isMusicLoading, setIsMusicLoading] = useState(false);
  const [error, setError] = useState(null);
  const [previewPlayingIndex, setPreviewPlayingIndex] = useState(null);

  const audioRef = useRef(null);
  const previewAudioRef = useRef(null);
  const songNameRef = useRef(null);
  const artistRef = useRef(null);
  const { setCoverColor } = useCoverColor();

  // API ÏÑ§Ï†ï
  const apiBaseUrl = "https://3.38.185.232:8080";

  // üî• MyPageBodyÏôÄ ÎèôÏùºÌïú ÌÜ†ÌÅ∞ Í∞ÄÏ†∏Ïò§Í∏∞ Ìï®Ïàò
  const getAuthToken = () => {
    // 1. propsÎ°ú Î∞õÏùÄ ÌÜ†ÌÅ∞ Ïö∞ÏÑ† ÏÇ¨Ïö©
    let token = authToken;

    // 2. propsÏóê ÏóÜÏúºÎ©¥ localStorageÏóêÏÑú ÏùΩÍ∏∞
    if (!token) {
      token = localStorage.getItem("authToken");
    }

    if (!token) {
      throw new Error("Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§. ÌÜ†ÌÅ∞Ïù¥ ÏóÜÏäµÎãàÎã§.");
    }

    // Bearer Ï†ëÎëêÏÇ¨Í∞Ä ÏóÜÏúºÎ©¥ Ï∂îÍ∞Ä
    return token.startsWith("Bearer ") ? token : `Bearer ${token}`;
  };

  // üî• Í∞ÑÎã®Ìïú ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
  const updateProfile = async (profileData) => {
    try {
      setIsSaving(true);
      setSaveError(null);

      const token = getAuthToken();

      const response = await fetch(`${apiBaseUrl}/api/profile`, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
          Authorization: token,
        },
        body: JSON.stringify(profileData),
      });

      // üî• 403 ÏóêÎü¨ Ï≤¥ÌÅ¨
      if (response.status === 403) {
        localStorage.removeItem("authToken");
        throw new Error("Ïù∏Ï¶ùÏù¥ ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§. Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥Ï£ºÏÑ∏Ïöî.");
      }

      if (response.status === 401) {
        localStorage.removeItem("authToken");
        throw new Error("Ïù∏Ï¶ùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥Ï£ºÏÑ∏Ïöî.");
      }

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const result = await response.json();
      console.log("‚úÖ ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏ ÏÑ±Í≥µ:", result);
      return result;
    } catch (error) {
      console.error("‚ùå ÌîÑÎ°úÌïÑ ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìå®:", error);
      setSaveError(error.message);

      // ÌÜ†ÌÅ∞ Í¥ÄÎ†® ÏóêÎü¨Ïù∏ Í≤ΩÏö∞ Î°úÍ∑∏Ïù∏ ÌéòÏù¥ÏßÄÎ°ú Î¶¨Îã§Ïù¥Î†âÌä∏
      if (error.message.includes("Î°úÍ∑∏Ïù∏") || error.message.includes("Ïù∏Ï¶ù")) {
        window.location.href = "/login";
      }

      throw error;
    } finally {
      setIsSaving(false);
    }
  };

  // üî• Í∞ÑÎã®Ìïú Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Ìï®Ïàò
  const uploadProfileImage = async (imageFile) => {
    try {
      setIsUploadingImage(true);

      const formData = new FormData();
      formData.append("file", imageFile);

      const token = getAuthToken();

      const response = await fetch(`${apiBaseUrl}/api/profile`, {
        method: "POST",
        headers: {
          Authorization: token,
        },
        body: formData,
      });

      if (response.status === 403) {
        localStorage.removeItem("authToken");
        throw new Error("Ïù∏Ï¶ùÏù¥ ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§. Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥Ï£ºÏÑ∏Ïöî.");
      }

      if (response.status === 401) {
        localStorage.removeItem("authToken");
        throw new Error("Ïù∏Ï¶ùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥Ï£ºÏÑ∏Ïöî.");
      }

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const result = await response.json();
      const imageUrl = result.data?.url || result.url;
      return imageUrl;
    } catch (error) {
      console.error("‚ùå Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Ïã§Ìå®:", error);

      if (error.message.includes("Î°úÍ∑∏Ïù∏") || error.message.includes("Ïù∏Ï¶ù")) {
        window.location.href = "/login";
      }

      throw error;
    } finally {
      setIsUploadingImage(false);
    }
  };

  // üî• MyPageBodyÏôÄ ÎèôÏùºÌïú Ïä§ÌÉÄÏùºÏùò ÌîÑÎ°úÌïÑ Î°úÎìú
  useEffect(() => {
    const fetchProfile = async () => {
      try {
        setIsImageLoading(true);
        setIsMusicDataLoading(true);
        setSaveError(null);

        // ÎèôÏ†ÅÏúºÎ°ú ÌÜ†ÌÅ∞ Í∞ÄÏ†∏Ïò§Í∏∞
        const token = getAuthToken();

        const response = await fetch(`${apiBaseUrl}/api/profile`, {
          method: "GET",
          headers: {
            Authorization: token,
          },
        });

        // üî• ÏÉÅÌÉú ÏΩîÎìú Ï≤¥ÌÅ¨
        if (response.status === 403) {
          localStorage.removeItem("authToken");
          throw new Error("Ïù∏Ï¶ùÏù¥ ÎßåÎ£åÎêòÏóàÏäµÎãàÎã§. Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥Ï£ºÏÑ∏Ïöî.");
        }

        if (response.status === 401) {
          localStorage.removeItem("authToken");
          throw new Error("Ïù∏Ï¶ùÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Îã§Ïãú Î°úÍ∑∏Ïù∏Ìï¥Ï£ºÏÑ∏Ïöî.");
        }

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        // üî• Îπà ÏùëÎãµ Ï≤¥ÌÅ¨
        const text = await response.text();
        if (!text || text.trim() === "") {
          console.log("ÏÑúÎ≤ÑÏóêÏÑú Îπà ÏùëÎãµÏùÑ Î∞õÏïòÏäµÎãàÎã§.");
          setIsImageLoading(false);
          setIsMusicDataLoading(false);
          return;
        }

        // üî• ÏïàÏ†ÑÌïú JSON ÌååÏã±
        const responseData = JSON.parse(text);
        console.log("‚úÖ ÌîÑÎ°úÌïÑ Îç∞Ïù¥ÌÑ∞ Î°úÎìú ÏÑ±Í≥µ:", responseData);

        const profileData = responseData.data;
        if (!profileData) {
          console.warn("‚ö†Ô∏è profileDataÍ∞Ä ÏóÜÏäµÎãàÎã§:", responseData);
          setIsImageLoading(false);
          setIsMusicDataLoading(false);
          return;
        }

        // Í∏∞Î≥∏ Ï†ïÎ≥¥ ÏÑ§Ï†ï
        setUserName(profileData.name || "");
        setQuoteCount(profileData.quoteCount || 0);

        // Ïª§Î≤Ñ ÏÉâÏÉÅ ÏÑ§Ï†ï
        if (profileData.coverColor) {
          const colorWithHash = profileData.coverColor.startsWith("#")
            ? profileData.coverColor
            : `#${profileData.coverColor}`;
          setSelectedColor(colorWithHash);
          setCoverColor(colorWithHash);
        }

        // Ïù∏Ïö©Íµ¨ Ï†ïÎ≥¥ ÏÑ§Ï†ï
        if (profileData.quote) {
          setData((prev) => ({
            ...prev,
            quote: {
              title: profileData.quote.title,
              text: profileData.quote.text,
            },
          }));
          setEditedQuoteTitle(profileData.quote.title);
          setEditedQuoteText(profileData.quote.text);
        }

        // Ìé∏ÏßëÏö© Ïù¥Î¶Ñ ÏóÖÎç∞Ïù¥Ìä∏
        setEditedUsername(profileData.name || mypageHeaderData.user.username);

        // Ïù¥ÎØ∏ÏßÄ Î°úÎî©
        if (profileData.profileImg) {
          const img = new Image();
          img.onload = () => {
            setSelectedImage(profileData.profileImg);
            setIsImageLoading(false);
          };
          img.onerror = () => {
            setIsImageLoading(false);
          };
          img.src = profileData.profileImg;
        } else {
          setIsImageLoading(false);
        }

        // ÏùåÏïÖ Ï†ïÎ≥¥ Î°úÎî©
        if (profileData.music) {
          try {
            const musicResponse = await fetch(
              `https://deezerdevs-deezer.p.rapidapi.com/search?q=${encodeURIComponent(
                `${profileData.music.song} ${profileData.music.artist}`
              )}`,
              {
                method: "GET",
                headers: {
                  "x-rapidapi-key":
                    "7138ae1e3cmsh63d4fa598445c5dp183b4ajsn1c9c5bdd5a48",
                  "x-rapidapi-host": "deezerdevs-deezer.p.rapidapi.com",
                },
              }
            );
            const musicResult = await musicResponse.json();

            if (musicResult.data?.[0]) {
              const foundMusic = musicResult.data[0];
              setMusicData({
                id: profileData.music.musicId || foundMusic.id,
                song: profileData.music.song,
                artist: profileData.music.artist,
                album: foundMusic.album.title,
                image: foundMusic.album.cover_medium || foundMusic.album.cover,
                preview: foundMusic.preview,
              });
            } else {
              setMusicData((prev) => ({
                ...prev,
                id: profileData.music.musicId,
                song: profileData.music.song,
                artist: profileData.music.artist,
              }));
            }
          } catch (error) {
            console.error("ÏùåÏïÖ Ïû¨Í≤ÄÏÉâ Ïò§Î•ò:", error);
            setMusicData((prev) => ({
              ...prev,
              id: profileData.music.musicId,
              song: profileData.music.song,
              artist: profileData.music.artist,
            }));
          } finally {
            setIsMusicDataLoading(false);
          }
        } else {
          setIsMusicDataLoading(false);
        }
      } catch (err) {
        console.error("‚ùå ÌîÑÎ°úÌïÑ Î°úÎî© Ïã§Ìå®:", err);
        setSaveError(err.message);
        setIsImageLoading(false);
        setIsMusicDataLoading(false);

        // ÌÜ†ÌÅ∞ Í¥ÄÎ†® ÏóêÎü¨Ïù∏ Í≤ΩÏö∞ Î°úÍ∑∏Ïù∏ ÌéòÏù¥ÏßÄÎ°ú Î¶¨Îã§Ïù¥Î†âÌä∏
        if (err.message.includes("Î°úÍ∑∏Ïù∏") || err.message.includes("Ïù∏Ï¶ù")) {
          window.location.href = "/login";
        }
      }
    };

    fetchProfile();
  }, []);

  // ÌÖçÏä§Ìä∏ Ïò§Î≤ÑÌîåÎ°úÏö∞ Ï≤¥ÌÅ¨ Î∞è Ïï†ÎãàÎ©îÏù¥ÏÖò Ï†ÅÏö©
  useEffect(() => {
    const checkTextOverflow = (element, text) => {
      if (element?.current) {
        const elementWidth = element.current.offsetWidth;
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        const fontSize = element === songNameRef ? "16px" : "13px";
        const fontFamily =
          element === songNameRef ? "Pretendard" : "PretendardL";
        context.font = `${fontSize} ${fontFamily}`;
        const textWidth = context.measureText(text).width;

        if (textWidth > elementWidth) {
          element.current.classList.add(styles.overflow);
        } else {
          element.current.classList.remove(styles.overflow);
        }
      }
    };

    checkTextOverflow(songNameRef, musicData.song);
    checkTextOverflow(artistRef, musicData.artist);
  }, [musicData.song, musicData.artist]);

  // Deezer API Í≤ÄÏÉâ
  const searchMusic = async (query) => {
    if (!query.trim()) {
      setSearchResults([]);
      return;
    }

    setIsMusicLoading(true);
    setError(null);

    try {
      const response = await fetch(
        `https://deezerdevs-deezer.p.rapidapi.com/search?q=${encodeURIComponent(
          query
        )}`,
        {
          method: "GET",
          headers: {
            "x-rapidapi-key":
              "7138ae1e3cmsh63d4fa598445c5dp183b4ajsn1c9c5bdd5a48",
            "x-rapidapi-host": "deezerdevs-deezer.p.rapidapi.com",
          },
        }
      );
      const result = await response.json();
      setSearchResults(result.data?.slice(0, 20) || []);
    } catch (err) {
      setError("ÏùåÏïÖ Í≤ÄÏÉâ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.");
      setSearchResults([]);
    } finally {
      setIsMusicLoading(false);
    }
  };

  // Í≤ÄÏÉâÏñ¥ ÎîîÎ∞îÏö¥Ïä§
  useEffect(() => {
    const timeoutId = setTimeout(() => {
      if (searchQuery && showMusicSearch) {
        searchMusic(searchQuery);
      }
    }, 500);
    return () => clearTimeout(timeoutId);
  }, [searchQuery, showMusicSearch]);

  // Î™®Îã¨ ÎØ∏Î¶¨Îì£Í∏∞
  const togglePreviewMusic = (musicIndex, previewUrl) => {
    if (!previewUrl) {
      alert("Ïù¥ Í≥°ÏùÄ ÎØ∏Î¶¨Îì£Í∏∞Í∞Ä Ï†úÍ≥µÎêòÏßÄ ÏïäÏäµÎãàÎã§.");
      return;
    }

    // Î©îÏù∏ ÌîåÎ†àÏù¥Ïñ¥ Ï†ïÏßÄ
    if (isPlaying) {
      audioRef.current?.pause();
      setIsPlaying(false);
    }

    // Îã§Î•∏ ÎØ∏Î¶¨Îì£Í∏∞ Ï†ïÏßÄ
    if (previewPlayingIndex !== null && previewPlayingIndex !== musicIndex) {
      previewAudioRef.current?.pause();
    }

    // ÌòÑÏû¨ Í≥° ÌÜ†Í∏Ä
    if (previewPlayingIndex === musicIndex) {
      previewAudioRef.current?.pause();
      setPreviewPlayingIndex(null);
    } else {
      if (previewAudioRef.current) {
        previewAudioRef.current.src = previewUrl;
        previewAudioRef.current
          .play()
          .catch(() => alert("ÎØ∏Î¶¨Îì£Í∏∞ Ïû¨ÏÉù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."));
        setPreviewPlayingIndex(musicIndex);
      }
    }
  };

  // ÏùåÏïÖ ÏÑ†ÌÉù
  const selectMusic = (selectedMusic) => {
    setMusicData({
      id: selectedMusic.id,
      song: selectedMusic.title,
      artist: selectedMusic.artist.name,
      album: selectedMusic.album.title,
      image: selectedMusic.album.cover_medium || selectedMusic.album.cover,
      preview: selectedMusic.preview,
    });
    setShowMusicSearch(false);
    setSearchQuery("");

    // ÎØ∏Î¶¨Îì£Í∏∞ Ï†ïÏßÄ
    previewAudioRef.current?.pause();
    setPreviewPlayingIndex(null);

    // Î©îÏù∏ ÌîåÎ†àÏù¥Ïñ¥ Ï†ïÏßÄ
    if (isPlaying) {
      audioRef.current?.pause();
      setIsPlaying(false);
    }
  };

  // Î©îÏù∏ ÌîåÎ†àÏù¥Ïñ¥ ÌÜ†Í∏Ä
  const togglePlayMusic = () => {
    if (!musicData.preview) {
      alert("Ïù¥ Í≥°ÏùÄ ÎØ∏Î¶¨Îì£Í∏∞Í∞Ä Ï†úÍ≥µÎêòÏßÄ ÏïäÏäµÎãàÎã§.");
      return;
    }

    if (isPlaying) {
      audioRef.current?.pause();
      setIsPlaying(false);
    } else {
      audioRef.current
        ?.play()
        .catch(() => alert("ÏùåÏïÖ Ïû¨ÏÉù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§."));
      setIsPlaying(true);
    }
  };

  // Ïò§ÎîîÏò§ Ïù¥Î≤§Ìä∏
  useEffect(() => {
    const audio = audioRef.current;
    if (audio) {
      const handleEnded = () => setIsPlaying(false);
      audio.addEventListener("ended", handleEnded);
      return () => audio.removeEventListener("ended", handleEnded);
    }
  }, [musicData.preview]);

  useEffect(() => {
    const audio = previewAudioRef.current;
    if (audio) {
      const handleEnded = () => setPreviewPlayingIndex(null);
      audio.addEventListener("ended", handleEnded);
      return () => audio.removeEventListener("ended", handleEnded);
    }
  }, []);

  // Ìé∏Ïßë ÏãúÏûë Ìï®Ïàò
  const startEditing = () => {
    setEditedUsername(userName);
    setEditedQuoteTitle(data.quote.title);
    setEditedQuoteText(data.quote.text);
    setSaveError(null);
    setIsEditing(true);
  };

  // Ï†ÄÏû• Ìï®Ïàò
  const handleSave = async () => {
    try {
      const profileData = {
        name: editedUsername,
        coverColor: selectedColor.replace("#", ""),
        music: {
          musicId: musicData.id ? musicData.id.toString() : "unknown",
          song: musicData.song,
          artist: musicData.artist,
        },
        quote: {
          title: editedQuoteTitle,
          text: editedQuoteText,
        },
      };

      console.log("Ï†ÑÏÜ°Ìï† Îç∞Ïù¥ÌÑ∞:", profileData);

      await updateProfile(profileData);

      // ÏÑ±Í≥µÏãú Î°úÏª¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
      setData((prevData) => ({
        ...prevData,
        user: { ...prevData.user, username: editedUsername },
        quote: {
          ...prevData.quote,
          title: editedQuoteTitle,
          text: editedQuoteText,
        },
      }));

      setUserName(editedUsername);
      setIsEditing(false);
    } catch (error) {
      alert(`ÌîÑÎ°úÌïÑ Ï†ÄÏû•Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: ${error.message}`);
    }
  };

  const handleColorSelect = (color) => {
    setSelectedColor(color);
    setCoverColor(color);
    setIsColorPickerOpen(false);
  };

  const handleImageChange = async (e) => {
    const file = e.target.files[0];
    if (file) {
      try {
        const localImageUrl = URL.createObjectURL(file);
        setSelectedImage(localImageUrl);

        if (isEditing) {
          const uploadedImageUrl = await uploadProfileImage(file);
          console.log("ÏóÖÎ°úÎìú Í≤∞Í≥º URL:", uploadedImageUrl);

          if (uploadedImageUrl) {
            setSelectedImage(uploadedImageUrl);
            alert("ÌîÑÎ°úÌïÑ Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏóÖÎ°úÎìúÎêòÏóàÏäµÎãàÎã§!");
          }
        }
      } catch (error) {
        console.error("Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìú Ïò§Î•ò:", error);
        alert(`Ïù¥ÎØ∏ÏßÄ ÏóÖÎ°úÎìúÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§: ${error.message}`);
      }
    }
  };

  const closeModal = () => {
    setShowMusicSearch(false);
    setSearchQuery("");
    setSearchResults([]);
    setError(null);
    previewAudioRef.current?.pause();
    setPreviewPlayingIndex(null);
  };

  return (
    <div className={styles.wrapper}>
      <Nav size="default" />
      {isEditing && <div className={styles.overlay}></div>}

      <div className={styles.container}>
        <div className={styles.imageWrapper}>
          {isEditing && (
            <label htmlFor="imageUpload" className={styles.cameraIconWrapper}>
              <FiCamera className={styles.cameraIcon} />
              {isUploadingImage && (
                <div className={styles.uploadingIndicator}>ÏóÖÎ°úÎìú Ï§ë...</div>
              )}
            </label>
          )}
          <label htmlFor="imageUpload">
            {isImageLoading ? (
              <div className={styles.imageLoadingContainer}>
                <div className={styles.imageLoadingSpinner}></div>
              </div>
            ) : (
              <img
                src={selectedImage || "assets/images/Mypagepicture.png"}
                alt="ÌîÑÎ°úÌïÑ"
                className={styles.profileImage}
              />
            )}
          </label>
          {isEditing && (
            <input
              id="imageUpload"
              type="file"
              accept="image/*"
              onChange={handleImageChange}
              style={{ display: "none" }}
              disabled={isUploadingImage}
            />
          )}
        </div>

        <div className={styles.infoSection}>
          <div className={styles.nameRow}>
            {isEditing ? (
              <>
                <input
                  className={styles.usernameInput}
                  value={editedUsername}
                  onChange={(e) => setEditedUsername(e.target.value)}
                />
                <button
                  className={styles.coverColorBtn}
                  onClick={() => setIsColorPickerOpen(!isColorPickerOpen)}
                >
                  Ïª§Î≤ÑÏÉâÏÉÅ
                </button>
                {isColorPickerOpen && (
                  <div className={styles.colorPicker}>
                    {[
                      "#b4005c",
                      "#e85454",
                      "#b681f2",
                      "#5f6d4e",
                      "#ffaa00",
                      "#89e1ff",
                      "#f4b2bc",
                      "#ffcfff",
                      "#4cb8b3",
                      "#c275b7",
                      "#e65c00",
                      "#1561b3",
                      "#b28f85",
                      "#ffe600",
                      "#444c6a",
                      "#c90000",
                    ].map((color) => (
                      <div
                        key={color}
                        className={styles.colorBox}
                        style={{ backgroundColor: color }}
                        onClick={() => handleColorSelect(color)}
                      />
                    ))}
                    <div
                      className={styles.moreColors}
                      onClick={() =>
                        setShowCustomColorInput(!showCustomColorInput)
                      }
                    >
                      <div className={styles.gradientDot}></div>
                      ÎçîÎ≥¥Í∏∞ +
                    </div>
                    {showCustomColorInput && (
                      <div className={styles.customColorInputWrapper}>
                        <HexColorPicker
                          color={customColor}
                          onChange={setCustomColor}
                        />
                        <button
                          className={styles.applyBtn}
                          onClick={() => handleColorSelect(customColor)}
                        >
                          Ï†ÅÏö©
                        </button>
                      </div>
                    )}
                  </div>
                )}
                <span className={styles.subtext}>
                  ÏûëÏÑ±Ìïú Íµ¨Ï†à {quoteCount}Í∞ú
                </span>
              </>
            ) : (
              <>
                <span className={styles.username}>{userName}</span>
                <span className={styles.subtext}>
                  ÏûëÏÑ±Ìïú Íµ¨Ï†à {quoteCount}Í∞ú
                </span>
              </>
            )}
          </div>

          <div className={styles.lowerSection}>
            <div
              className={`${styles.quoteBox} ${
                isEditing ? styles.editingQuoteBox : ""
              }`}
            >
              {isEditing ? (
                <>
                  <input
                    className={styles.quoteTitleInput}
                    value={editedQuoteTitle}
                    onChange={(e) => setEditedQuoteTitle(e.target.value)}
                    style={{ color: selectedColor }}
                  />
                  <textarea
                    className={styles.quoteTextArea}
                    value={editedQuoteText}
                    onChange={(e) => setEditedQuoteText(e.target.value)}
                    style={{ color: selectedColor }}
                  />
                  <button
                    className={styles.completeBtn}
                    onClick={handleSave}
                    disabled={isSaving}
                  >
                    {isSaving ? "Ï†ÄÏû• Ï§ë..." : "ÏôÑÎ£å"}
                  </button>
                </>
              ) : (
                <>
                  <h3
                    className={styles.quoteTitle}
                    style={{ color: selectedColor }}
                  >
                    {data.quote.title}
                  </h3>
                  <p
                    className={styles.quoteText}
                    style={{ color: selectedColor }}
                  >
                    {data.quote.text}
                  </p>
                </>
              )}
            </div>

            <div className={styles.actionSection}>
              <div className={styles.buttons}>
                <button
                  className={styles.btn}
                  onClick={startEditing}
                  style={{ color: selectedColor }}
                >
                  <FiSettings className={styles.icon} />
                  ÌîÑÎ°úÌïÑ Ìé∏Ïßë
                </button>
              </div>

              <div
                className={`${styles.music} ${isPlaying ? styles.playing : ""}`}
                style={{
                  backgroundColor: isEditing
                    ? "rgba(255, 255, 255, 0.9)"
                    : "rgba(255, 255, 255, 0.5)",
                  color: selectedColor,
                  cursor: isEditing ? "pointer" : "default",
                }}
                onClick={() => isEditing && setShowMusicSearch(true)}
              >
                {isMusicDataLoading ? (
                  <div className={styles.musicLoadingContainer}>
                    <div className={styles.musicLoadingSpinner}></div>
                    <div className={styles.musicLoadingText}>
                      ÏùåÏïÖ Ï†ïÎ≥¥ Î∂àÎü¨Ïò§Îäî Ï§ë...
                    </div>
                  </div>
                ) : (
                  <>
                    {musicData.image && (
                      <img
                        src={musicData.image}
                        alt="Ïï®Î≤î Ïª§Î≤Ñ"
                        className={styles.albumCoverImage}
                      />
                    )}
                    <button
                      className={styles.playButton}
                      onClick={(e) => {
                        e.stopPropagation();
                        togglePlayMusic();
                      }}
                      style={{ color: selectedColor }}
                    >
                      {isPlaying ? (
                        <FaPause className={styles.playIcon} />
                      ) : (
                        <FaPlay className={styles.playIcon} />
                      )}
                    </button>
                    <div className={styles.musicInfo}>
                      <p ref={songNameRef} className={styles.songname}>
                        {musicData.song}
                      </p>
                      <span ref={artistRef} className={styles.artist}>
                        {musicData.artist}
                      </span>
                    </div>
                  </>
                )}
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* ÏùåÏïÖ Í≤ÄÏÉâ Î™®Îã¨ */}
      {showMusicSearch && (
        <div className={styles.musicSearchModal}>
          <div className={styles.musicSearchContainer}>
            <div className={styles.searchHeader}>
              <h3>Í≥°ÏùÑ Í≤ÄÏÉâÌï¥Ï£ºÏÑ∏Ïöî</h3>
              <button className={styles.closeBtn} onClick={closeModal}>
                ‚úï
              </button>
            </div>

            <div className={styles.searchInputContainer}>
              <input
                type="text"
                placeholder="Í≥°Î™Ö, ÏïÑÌã∞Ïä§Ìä∏Î•º Í≤ÄÏÉâÌï¥Î≥¥ÏÑ∏Ïöî"
                className={styles.musicSearchInput}
                value={searchQuery}
                onChange={(e) => setSearchQuery(e.target.value)}
              />
              <button className={styles.searchIcon}>üîç</button>
            </div>

            <div className={styles.musicList}>
              {isMusicLoading && (
                <div className={styles.loading}>Í≤ÄÏÉâ Ï§ë...</div>
              )}
              {!isMusicLoading &&
                !error &&
                searchResults.length === 0 &&
                searchQuery && (
                  <div className={styles.loading}>Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§.</div>
                )}
              {!isMusicLoading && !error && searchQuery === "" && (
                <div className={styles.loading}>Í≤ÄÏÉâÏñ¥Î•º ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.</div>
              )}

              {searchResults.map((music, index) => (
                <div
                  key={index}
                  className={styles.musicItem}
                  onClick={() => selectMusic(music)}
                >
                  <div className={styles.albumCover}>
                    {music.album.cover_small ? (
                      <img
                        src={music.album.cover_small}
                        alt={music.title}
                        style={{
                          width: "100%",
                          height: "100%",
                          objectFit: "cover",
                          borderRadius: "8px",
                        }}
                      />
                    ) : (
                      <span style={{ fontSize: "20px" }}>üéµ</span>
                    )}
                  </div>
                  <div className={styles.musicInfoModal}>
                    <div className={styles.songTitle}>{music.title}</div>
                    <div className={styles.artistName}>{music.artist.name}</div>
                  </div>
                  <button
                    className={styles.playBtn}
                    onClick={(e) => {
                      e.stopPropagation();
                      togglePreviewMusic(index, music.preview);
                    }}
                  >
                    {previewPlayingIndex === index ? "‚è∏" : "‚ñ∂"}
                  </button>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* Ïò§ÎîîÏò§ ÏóòÎ¶¨Î®ºÌä∏ */}
      {musicData.preview && (
        <audio
          ref={audioRef}
          src={musicData.preview}
          onEnded={() => setIsPlaying(false)}
        />
      )}
      <audio ref={previewAudioRef} />
    </div>
  );
}
